
\section{Description générale du problème}
\subsection{Introduction}

Pour ce projet d'informatique, nous avons décidé de prendre un sujet autre que ceux proposés par nos enseignants.  Ayant fait tous les deux une année zéro dans la marine nationale, un sujet proche de ce que l'on avait vécut semblait la solution évidente.

Nous sommes donc parti sur un jeu de type bataille navale, en temps réel et multijoueurs que nous avons nommé :

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\linewidth]{../imgs/logo}
	\caption{Logo du projet d'informatique}
	\label{fig:logo}
\end{figure}

\subsection{Les différentes pistes envisagées}

Pour le choix de l'interface Homme-Machine (IHM) le choix s'est rapidement porté sur \textbf{PyQt5} pour sa polyvalence et sa programmation évènementielle. Concernant la connexion entre le serveur et les clients,  nous sommes tout d'abord partis sur la bibliothèque \textbf{sockets} qui permet de créer un tunnel simple entre deux clients. Nous avons finalement choisi \textbf{asyncio}, implémentée depuis python3, qui permet de gérer en asynchrone toutes les requêtes nécessaires au projet, et ce avec plusieurs clients en simultané.

\subsection{Différentes hypothèses réductrices choisies}

Pour réduire la taille du projet et surtout le rendre réalisable, nous avons choisi d'établir quelques réductions pour cette première partie : 
\begin{itemize}
	\item Le positionnement et le déplacement des joueurs et entités se fait une une grille de $8\times 8$ pixels.
	\item Les joueurs ne sont pas visibles par les autres joueurs.
	\item Le chat ne peut accueillir que du texte, donc pas de commande\\ (du type \emph{/help}.
	\item La vitesse de rafraichissement, ou le nombre de boucles de jeu par seconde est indépendant selon la classe.
	
\end{itemize}

\clearpage
\section{Application proprement dite}
\subsection{Présentation générale du programme}
Le programme est scindé en deux partie : le client et le serveur avec chacun son script pour le lancer. Le script \emph{test$\_$suite.py} permet de lancer tous les tests unitaires contenus dans le dossier \emph{tests}.

\subsubsection{Le serveur}
Lancer le serveur avec le script \emph{serveur.py}, crée un serveur sur l'hôte \emph{localhost} (127.0.0.1 ou 0.0.0.0). sur le port 25566.
Le serveur va ensuite accueillir les nouveaux joueurs, organiser le chat et gérer toutes les entités du jeu. Une fois lancé et opérationnel le terminal de commande ressemble à cela :

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{../imgs/serveur_screen}
	\caption{Ecran de fonctionnement du serveur}
	\label{fig:serveur_screen}
\end{figure}

Une fois démarré le serveur affichera les informations utiles telles que le nom de la machine sur laquelle il est exécuté, son ip locale, le port de connexion et le nombre de joueurs maximum (pas encore implémenté).

\subsubsection{Le client}
Une fois le serveur lancé en local, on peut soit se connecter à ce dernier, soit se connecter à un serveur que nous laisserons ouvert chez nous, pré-enregistré dans la liste des serveurs disponibles.

En démarrant le client avec le script \emph{client.py}, on se trouve devant l'écran de connexion du projet. (cf. \ref{fig:ecran_connexion})

Sur celui-ci l'utilisateur pourra retrouver les serveurs pré-enregistrés ainsi qu'une boite pour indiquer son pseudonyme, un bouton pour se connecter au serveur sélectionné. 

Enfin l'utilisateur trouvera  un bouton "Serveur local" pour entrer manuellement les informations de connexion au serveur (cf. \ref{fig:serveur_local})

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{../imgs/connexion_screen}
	\caption{Ecran de connexion client}
	\label{fig:ecran_connexion}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{../imgs/serveur local}
	\caption{Boite de dialogue de connexion manuelle à un serveur}
	\label{fig:serveur_local}
\end{figure}

Une fois connecté au serveur, l'utilisateur est face à l'écran de jeu (cf. \ref{fig:ecran_jeu}) qui comporte une surface de jeu, que nous appellerons \emph{canvas}, sur laquelle sera dessinée la carte, les entités et les joueurs. On y retrouve un radar permettant de détecter les entités aux alentours (attention pas entièrement fonctionnel pour l'instant), et une chatbox pour communiquer avec les autres joueurs présent sur le serveur.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{../imgs/game_screen}
	\caption{Ecran de jeu du projet}
	\label{fig:ecran_jeu}
\end{figure}

Pour cette première phase, nous nous sommes concentré sur la structure du jeu. Par conséquent les contrôles joueur sont limités. Pour se déplacer l'utilisateur pourra utiliser les flèches du clavier dès que le focus est sur le canvas (un click souris sur le canvas suffit à récupérer le focus).

\subsection{Description des principales classes/méthodes}
% décrire uniquement les mécanismes fondamentaux
\paragraph{classes de jeu\\}



En premier lieu, il convient de décrire les classes directement liés au fonctionnement du jeu. 
La classe "Entité" est la base d'une joueur, qu'il soit réel ou contrôlé par la machine. Elle va notamment avoir des attributs de points de vie, de position dans la map ou encore d'arme actuellement sélectionné par le joueur.
Une entité peut être "joueur" ou "pnj". Une entité interagit avec les autres entités par le biais du client de jeu, les entité "pnj" sont elles contrôlés par le serveur. Une entité à un instant t contrôle un bâtiment et sélectionne une arme disponible sur ce bâtiment. La classe "Batiment" contient toutes les statistiques et données sur un bâtiment, cela peut être son niveau, les points de vie maximaux, ou encore la portée de détection. La classe "Armes" quand à elle définie les données des différentes armes disponibles. 

\paragraph{classe de l'IHM\\}


Dans l'IHM, nous avons intégré plusieurs éléments qui nécessite leur propre classe. 
La classe "Radar" est une classe hérité de Qwidget. Elle gère le radar de détection des autres entités ennemies. \\La règle du jeu veut que si un ennemi se trouve dans notre portée de détection et que cette ennemi a une dissimulation (implémentée plus tard) supérieur à la distance qui nous sépare d'elle, cette ennemi sera affiché par un point rouge sur le radar. \\Le radar balaye l'espace à 90°/s. On garde les traces d'un ennemie détecté en rouge puis en gris lorsqu'elles s'apprêtent à disparaitre du radar. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{../imgs/radar}
	\caption{Aperçu du Radar}
	\label{fig:radar}
\end{figure}


La classe "Chatbox" comme son nom l'indique renvoi à la chat box en bas à droite du canevas de jeu. Elle est héritée de Qtextbrowser. Cette classe existe car on doit pouvoir écrire sur le chat pendant que le jeu tourne, il est donc nécessaire de créer un autre thread, sur lequel tourne la chatbox, et dans lequel Qt va piocher les informations lorsque nécessaire.\\ Elle contient une liste de lignes qui est mise à jour avec les messages des autres joueurs. Un signal Qt permet d'envoyer un message en appuyant sur la touche Entrée. 

\paragraph{classe du client/serveur}

\clearpage
\section{Conclusion}

\subsection{Différents tests effectués}

\subsection{Limitations}

Nous avons rencontré quelques limitations durant ce projet.\\En premier lieu, l'usage d'une mode multijoueur implique une utilisation extensive de la bande passante, ce qui nécessite d'optimiser les requêtes afin de ne pas surcharger un réseau. \\Ensuite le fait que Pickle ne gère pas directement QT, hors nos messages sont encodés en pickel et envoyé sur le réseau. Il à donc fallut passer par des classes annexes comme "ChatBox" afin de contourner cette limitation. \\Nous avons pu contourner ces limitations et les seuls réels limitations de notre projet sont plus de l'ordre de la performance que du fonctionnement. 


\subsection{Perspectives d'amélioration}

On pourrait améliorer la dynamique des bâtiments, en leur donnant des caractéristiques d'inertie ou encore de rayon de giration, ce qui aurait été plus réaliste (on ne manoeuvre pas un porte-avions comme un BIN). 
\\On pourrait encore implémenter un concept de dégât critique, avec des équipements importants du bâtiment qui pourrait être mis temporairement hors d'usage après un coup bien placé (armement, radar, propulsion). 


